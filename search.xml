<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>POJ1321</title>
    <url>/46061/</url>
    <content><![CDATA[<h1 id="POJ1321棋盘问题"><a href="#POJ1321棋盘问题" class="headerlink" title="POJ1321棋盘问题"></a>POJ1321棋盘问题</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>  在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p>
<a id="more"></a>

<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>  本题和<a href="https://seanaristotle.github.io/2019/05/18/codevs1259/#more">N皇后问题</a>唯一的区别就是摆放的棋子数可以小于棋盘大小N，这里采用每行都可以有一次那个元素都不选的机会，在代码的<strong>第44行</strong> 体现这个操作，这就可以解决这个问题。另外由于加了选择的参数，所以在判断是否增加答案数量是的判断也改了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a,0,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>;<span class="comment">//须填写</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pic[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> results;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">research</span><span class="params">(<span class="keyword">int</span> floors, <span class="keyword">int</span> select)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(select == k)</span><br><span class="line">    &#123;</span><br><span class="line">        results++;</span><br><span class="line">        <span class="comment">//printf(&quot;%d\n&quot;,results);判断为有用路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(floors &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;pic[floors][i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//printf(&quot;floors=%d  lie=%d\n&quot;,floors,i);这个用来输出路径</span></span><br><span class="line">                research(floors+<span class="number">1</span>, select+<span class="number">1</span>);</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        research(floors+<span class="number">1</span>,select);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;sample.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;sample.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k)&amp;&amp;(n!=<span class="number">-1</span>)&amp;&amp;(k!=<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        results = <span class="number">0</span>;</span><br><span class="line">        mem(vis);</span><br><span class="line">        mem(pic);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,pic[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        research(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,results);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
        <tag>搜索</tag>
        <tag>kuangbin带你飞1</tag>
      </tags>
  </entry>
  <entry>
    <title>codevs1259</title>
    <url>/29278/</url>
    <content><![CDATA[<h1 id="codevs1259-N皇后问题"><a href="#codevs1259-N皇后问题" class="headerlink" title="codevs1259 N皇后问题"></a>codevs1259 N皇后问题</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于再n×n的棋盘上放置n个皇后，任何2个皇后不妨在同一行或同一列或同一斜线上。</p>
<a id="more"></a>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>本来开始的第一个题目并不是他，而是<a href="https://seanaristotle.github.io/2019/05/18/POJ1321/#more"><strong>poj1321</strong></a>，但是我竟然菜到连这个八皇后问题的简单变体，一个简单的搜索都有点懵逼，吓得我抓紧打开liurujia的紫书好好重新学习了一下。<br>题目没有什么坑点，就是简单的回溯法求解</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">using namespace std ;</span><br><span class="line"></span><br><span class="line">#define mem(a) memset(a,0,sizeof(a))</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">const int maxn &#x3D; 110010;&#x2F;&#x2F;须填写</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int results;</span><br><span class="line">int dis[3][50];</span><br><span class="line"></span><br><span class="line">void reserch(int floors, int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(floors &#x3D;&#x3D; n)</span><br><span class="line">        results++;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!dis[0][i]&amp;&amp;(!dis[1][i+floors])&amp;&amp;(!dis[2][n-floors-1+i]))</span><br><span class="line">        &#123;</span><br><span class="line">            dis[0][i] &#x3D; dis[1][i+floors] &#x3D; dis[2][n-floors-1+i] &#x3D; 1;</span><br><span class="line">            reserch(floors+1, n);</span><br><span class="line">            dis[0][i] &#x3D; dis[1][i+floors] &#x3D; dis[2][n-floors-1+i] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    mem(dis);</span><br><span class="line">    results &#x3D; 0;</span><br><span class="line">    reserch(0, n);</span><br><span class="line">    printf(&quot;%d\n&quot;, results);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>poj2386</title>
    <url>/61453/</url>
    <content><![CDATA[<h1 id="POJ2386-Lake-Counting"><a href="#POJ2386-Lake-Counting" class="headerlink" title="POJ2386 Lake Counting"></a>POJ2386 Lake Counting</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. </p>
<a id="more"></a>

<p>题目和<a href="https://seanaristotle.github.io/2019/05/19/uva572/#more">UVA572</a>一毛一样，就是换了个符号表示，不多说了。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>  <strong>我光明正大的表示，就是划水，你打我啊～～～</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">using namespace std ;</span><br><span class="line"></span><br><span class="line">#define mem(a) memset(a,0,sizeof(a))</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">const int maxn &#x3D; 110;&#x2F;&#x2F;须填写</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">char pic[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int s)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&lt;0||y&lt;0||x&gt;&#x3D;m||y&gt;&#x3D;n)</span><br><span class="line">        return ;</span><br><span class="line">    for(int i&#x3D;-1;i&lt;2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;-1;j&lt;2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(vis[i+x][j+y] &#x3D;&#x3D; 0&amp;&amp;pic[i+x][j+y]&#x3D;&#x3D;&#39;W&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i+x][j+y] &#x3D; s;</span><br><span class="line">                dfs(i+x,j+y,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;sample.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    int results;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line"></span><br><span class="line">    results &#x3D; 0;</span><br><span class="line">    mem(vis);</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s&quot;,pic[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(vis[i][j] &#x3D;&#x3D; 0&amp;&amp;pic[i][j]&#x3D;&#x3D;&#39;W&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i][j] &#x3D; ++results;</span><br><span class="line">                dfs(i,j,results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,results);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>poj3620</title>
    <url>/44954/</url>
    <content><![CDATA[<h1 id="POJ3620Avoid-The-Lakes"><a href="#POJ3620Avoid-The-Lakes" class="headerlink" title="POJ3620Avoid The Lakes"></a>POJ3620Avoid The Lakes</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>  The farm is represented as a rectangular grid with N (1 ≤ N ≤ 100) rows and M (1 ≤ M ≤ 100) columns. Each cell in the grid is either dry or submerged, and exactly K (1 ≤ K ≤ N × M) of the cells are submerged. As one would expect, a lake has a central cell to which other cells connect by sharing a long edge (not a corner). Any cell that shares a long edge with the central cell or shares a long edge with any connected cell becomes a connected cell and is part of the lake.</p>
<a id="more"></a>
<p>  与<a href="https://seanaristotle.github.io/2019/05/19/uva572/#more">UVA572</a>不同的是，本题不需求连通块的数量，需要的是最大的连通分量的大小，而且连通的规则也改为了只能上下左右才可以。</p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>  这个题的思路是这样的，除了之前说过的求连通分量的数组外，额外加了一个存连通分量大小的数组，最后将这个数组有大到小排序，输出数组的第一个元素即可。<br>  这个题代码部分DFS函数没写好，因为其他的错误以为DFS边界写错了，于是添加了冗余代码。<br>DFS判断边界情况只需要考虑当前情况即可。引以为戒。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define mem(a) memset(a,0,sizeof(a))</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">const int maxn &#x3D; 110;&#x2F;&#x2F;须填写</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int pic[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int num[maxn*maxn];</span><br><span class="line"></span><br><span class="line">bool cmp(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">      return a&gt;b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int y,int s)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&lt;1||y&lt;1||x&gt;n||y&gt;m)</span><br><span class="line">        return ;</span><br><span class="line">    if(!vis[x-1][y]&amp;&amp;pic[x-1][y]&#x3D;&#x3D;1&amp;&amp;x-1&gt;&#x3D;1)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[x-1][y]&#x3D;s;</span><br><span class="line">        num[s]++;</span><br><span class="line">        dfs(x-1,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!vis[x+1][y]&amp;&amp;pic[x+1][y]&#x3D;&#x3D;1&amp;&amp;x+1&lt;&#x3D;n)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[x+1][y]&#x3D;s;</span><br><span class="line">        num[s]++;</span><br><span class="line">        dfs(x+1,y,s);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!vis[x][y-1]&amp;&amp;pic[x][y-1]&#x3D;&#x3D;1&amp;&amp;y-1&gt;&#x3D;1)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[x][y-1]&#x3D;s;</span><br><span class="line">        num[s]++;</span><br><span class="line">        dfs(x,y-1,s);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!vis[x][y+1]&amp;&amp;pic[x][y+1]&#x3D;&#x3D;1&amp;&amp;y+1&lt;&#x3D;m)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[x][y+1]&#x3D;s;</span><br><span class="line">        num[s]++;</span><br><span class="line">        dfs(x,y+1,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;sample.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    mem(vis);</span><br><span class="line">    mem(pic);</span><br><span class="line">    mem(num);</span><br><span class="line">    int k,x,y;</span><br><span class="line">    int results &#x3D; 0;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    for(int i&#x3D;0;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">        pic[x][y] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(vis[i][j]&#x3D;&#x3D;0&amp;&amp;pic[i][j]&#x3D;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i][j] &#x3D; ++results;</span><br><span class="line">                num[results]++;</span><br><span class="line">                dfs(i,j,results);</span><br><span class="line">                &#x2F;&#x2F;printf(&quot;%d   %d      %d\n&quot;,i,j,num[results]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(num,num+results+1,cmp);</span><br><span class="line">    printf(&quot;%d\n&quot;,num[0]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>poj3984</title>
    <url>/53165/</url>
    <content><![CDATA[<h1 id="POJ3984迷宫问题"><a href="#POJ3984迷宫问题" class="headerlink" title="POJ3984迷宫问题"></a>POJ3984迷宫问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>  给出一个5×5的数字矩阵其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。</p>
<a id="more"></a>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>  事实证明，bfs对这种数字矩阵的处理能力明显不如dfs，bfs对距离矩阵的处理更强。<br>  之前对图的处理多是那种邻接矩阵的处理，但是对这种数字矩阵的处理要差很多，刚开始做法大体是知道，但是编程时却有点蒙，基础太差了。<br>  首先，回忆一下bfs。bfs就是广度优先搜索，从起始点开始，将这个点相连的点加入到队列之中，标记经过的点，然后依次将队列中的点取出，然后加入与这个点相连的点（要并未访问过的），因为队列先进先出的规律，所以就可以分层次遍历途中所有点。这里值得注意的是，由于是从开始分层遍历，所以先经过的点一定是最优的。即如果某个点是最短路的必经之路，那么第一次访问它的前一个节点也一定是必经之路。通过这个特点，就可以在将点加入队列的时候，顺便记录一下他的父亲节点（即这个节点的上一个节点）。这样通过队最后一个节点开始递归，就可以找到最短路径了。<br>  记录路径时，因为这个图只有上下左右四个方向，所以可以通过方向记录，空间上这么做更为优秀，但是为了之后处理距离矩阵的图，所以用struct数组存点的路径。另外我的代码并没有采用递归，而是使用差不多的栈结构。在路径比较长时，可以使用vector代替，但是本题不需要，我就懒着了吧^_^。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std ;</span><br><span class="line"></span><br><span class="line">#define mem(a) memset(a,0,sizeof(a))</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">const int maxn &#x3D; 110010;&#x2F;&#x2F;须填写</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int dir[4][2]&#x3D;&#123;</span><br><span class="line">    0,-1,   &#x2F;&#x2F;up</span><br><span class="line">    0,1,    &#x2F;&#x2F;down</span><br><span class="line">    -1,0,   &#x2F;&#x2F;left</span><br><span class="line">    1,0,    &#x2F;&#x2F;rights</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int vis[10][10];</span><br><span class="line">int pic[10][10];</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">Node way[10][10];</span><br><span class="line"></span><br><span class="line">void bfs(Node node)</span><br><span class="line">&#123;</span><br><span class="line">    queue &lt;Node&gt; que;</span><br><span class="line">    Node n;</span><br><span class="line">    int x,y;</span><br><span class="line">    que.push(node);</span><br><span class="line">    vis[node.x][node.y]&#x3D;1;</span><br><span class="line">    way[node.x][node.y].x&#x3D;-1;</span><br><span class="line">    while(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        n&#x3D;que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        for(int i&#x3D;0;i&lt;4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            x&#x3D;n.x+dir[i][0];</span><br><span class="line">            y&#x3D;n.y+dir[i][1];</span><br><span class="line">            if(x&gt;&#x3D;0&amp;&amp;x&lt;5&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;5&amp;&amp;pic[x][y]&#x3D;&#x3D;0&amp;&amp;vis[x][y]&#x3D;&#x3D;0)</span><br><span class="line">            &#123;</span><br><span class="line">                way[x][y]&#x3D;n;</span><br><span class="line">                n.x&#x3D;x;</span><br><span class="line">                n.y&#x3D;y;</span><br><span class="line">                vis[x][y]&#x3D;1;</span><br><span class="line">                que.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    for(int i&#x3D;0;i&lt;5;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;5;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;pic[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node;</span><br><span class="line">    stack&lt;Node&gt; s;</span><br><span class="line">    node.x&#x3D;0;</span><br><span class="line">    node.y&#x3D;0;</span><br><span class="line">    bfs(node);</span><br><span class="line">    node.x&#x3D;4;</span><br><span class="line">    node.y&#x3D;4;</span><br><span class="line">    while(node.x!&#x3D;-1)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push(node);</span><br><span class="line">        node&#x3D;way[node.x][node.y];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    while(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node&#x3D;s.top();</span><br><span class="line">        printf(&quot;(%d, %d)\n&quot;,node.x,node.y);</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>迷宫问题</tag>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title>uva572 Oil Deposits</title>
    <url>/47450/</url>
    <content><![CDATA[<h1 id="UVA572-Oil-Deposits"><a href="#UVA572-Oil-Deposits" class="headerlink" title="UVA572 Oil Deposits"></a>UVA572 Oil Deposits</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>  The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits.<br>GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil.<br>题目意思很简单，就是说图像中@符号不管是横这竖着斜着，只要连着，就是一片油田，问一共有多少油田。</p>
<a id="more"></a>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>虐简简单题的时候来了，本博客纯属为了凑篇数的虐菜题。这个题就是简单的DFS求连通块的问题，核心的思想就是用vis数组记录是否访问过。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">using namespace std ;</span><br><span class="line"></span><br><span class="line">#define mem(a) memset(a,0,sizeof(a))</span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">const int maxn &#x3D; 110;&#x2F;&#x2F;须填写</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">char pic[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int s)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&lt;0||y&lt;0||x&gt;&#x3D;m||y&gt;&#x3D;n)</span><br><span class="line">        return ;</span><br><span class="line">    for(int i&#x3D;-1;i&lt;2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;-1;j&lt;2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(vis[i+x][j+y] &#x3D;&#x3D; 0&amp;&amp;pic[i+x][j+y]&#x3D;&#x3D;&#39;@&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i+x][j+y] &#x3D; s;</span><br><span class="line">                dfs(i+x,j+y,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    &#x2F;&#x2F;freopen(&quot;sample.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    int results;</span><br><span class="line">    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)&amp;&amp;n&amp;&amp;m)</span><br><span class="line">    &#123;</span><br><span class="line">        results &#x3D; 0;</span><br><span class="line">        mem(vis);</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%s&quot;,pic[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(vis[i][j] &#x3D;&#x3D; 0&amp;&amp;pic[i][j]&#x3D;&#x3D;&#39;@&#39;)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[i][j] &#x3D; ++results;</span><br><span class="line">                    dfs(i,j,results);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,results);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流问题综述</title>
    <url>/18548/</url>
    <content><![CDATA[<h1 id="最大流问题综述"><a href="#最大流问题综述" class="headerlink" title="最大流问题综述"></a>最大流问题综述</h1><h2 id="问题起源："><a href="#问题起源：" class="headerlink" title="问题起源："></a>问题起源：</h2><p>  之前CCF的时候就有一道步骤繁多的最小费用最大流水题，但那个时候太菜了，连网络流是什么都不知道，此题当然无从做起。后来刷比赛我不是专门负责这个的人，网络流的系统化学习也就没有纳入日程中来。今日闲来无事就决定从网络流下刀，也算是率先了却自己的一个遗憾。<a id="more"></a><br>  本篇博客借鉴了多位网络上大佬的博客，将会在文尾一一感谢。</p>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>  在S点表示的是一个交通枢纽，此处有无限量车等待出发去T点（T点是另一个交通枢纽，可以接受无限量车）。途中经过不同的道路和交叉路口，而每条道路单位时间内承载的车辆数目是有限的，求单位时间内能到达T点的车辆最大是多少？</p>
<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p><img src="/home/sean/seanaristotlepicture/%E6%9C%80%E5%A4%A7%E6%B5%81%E5%9F%BA%E7%A1%80.png"></p>
<p>  如图所示，S点到1点和2点的单位时间车流量分别是1。很好理解网络流问题需要求解的问题。</p>
<h2 id="问题解析（FF，EK，Dinic-SAP-ISAP…）"><a href="#问题解析（FF，EK，Dinic-SAP-ISAP…）" class="headerlink" title="问题解析（FF，EK，Dinic, SAP, ISAP…）"></a>问题解析（FF，EK，Dinic, SAP, ISAP…）</h2><h3 id="贪心思路"><a href="#贪心思路" class="headerlink" title="贪心思路"></a>贪心思路</h3><p>  刚刚见到网络流问题的任第一反应就是贪心算法（虽然网络上没有提及这个问题，但是我感觉到其实当大家面对从未见过的问题是想到的往往就是比如贪心，动归这四大基础算法。在解决问题的过程中采取已有的或没有的优化方法来达到目的，进而创造出了新的算法。），但是这个思路是有缺陷的。比如在贪心的过程中，你选择的路径是S-&gt;1-&gt;2-&gt;T，那么你得到的答案1，这显然是不正确的。</p>
<p>  我们在贪心的方法上碰了壁，究其原因是因为在选择的过程中做出了错误的选择：1-&gt;2。从而导致路线</p>
<p>S-&gt;1-&gt;T,  S-&gt;2-&gt;T 两条路径无法使用。我们引入一个新的想法，给予算法选择路径时反悔机会，这就是反向边的概念。</p>
<p>  这里对反向边的理解是在匈牙利算法中得到的（其实二分图匹配也是一种变相的网络流）。此处附一则匈牙利算法的博客，<a href="%3Chttps://blog.csdn.net/qq_41730082/article/details/81162561%3Es">学习使我们快乐</a>。而这种返回的机会是通过在算法作出错误决定而阻塞了一条增广路径时（S-&gt;1-&gt;2-&gt;T），总能空出一条新的增广路径（S-&gt;2-&gt;1-&gt;T）来弥补他。</p>
<h3 id="FF方法（Ford-Fulkerson方法）"><a href="#FF方法（Ford-Fulkerson方法）" class="headerlink" title="FF方法（Ford-Fulkerson方法）"></a>FF方法（Ford-Fulkerson方法）</h3><p>  之所以称之为方法而而不是算法，是因为它包含了几种运行时间各不相同的具体实现。Ford-Fulkerson方法依赖于三种重要的思想：残存网络、增广路径和切割。</p>
<p>  一条路的承载量减去现在这条路上的占用量叫残存量。残存量不为零的路叫残存路。整个网络流中可以从S点到T点的残存路组成了残存网络。增光路就是残存网络中可以从S点到T点的一条路。而切割就是切断一条路，从S点到T点的总流量会减少的路。</p>
<p>  有了FF方法，我们可以不用盲目的贪心，而是直接找出一条从起点到终点的路径，然后记录流量，并修改这些路径的残存量。并且由于加了反向边的概念，所以不用担心寻找不好的路径引起的后续问题。而一说到寻找路径自然想到DFS和BFS这两种最基础的算法。</p>
<h4 id="FF方法的DFS实现"><a href="#FF方法的DFS实现" class="headerlink" title="FF方法的DFS实现"></a>FF方法的DFS实现</h4><p>  其实我感觉DFS在寻找路径上是比BFS要好用的，所以在一开始接触FF方法时我第一反应就是使用DFS（但遗憾的是DFS存在最坏情况下面将讲到）。</p>
]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>最大流</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo和github搭建个人博客</title>
    <url>/16107/</url>
    <content><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><p>1.github账号</p>
<p>2.git for Windows</p>
<p>3.node.js</p>
<p>4.npm</p>
<h2 id="Github账号"><a href="#Github账号" class="headerlink" title="Github账号"></a>Github账号</h2><p>​       Github 仓库是你博客存储的地方，是构建博客的起点，点击<a href="https://github.com/">这里</a>去官网注册一个就好了。</p>
<h2 id="Git-for-windows"><a href="#Git-for-windows" class="headerlink" title="Git for windows"></a>Git for windows</h2><p>​       Git for Windows是用来将你的博客生成并部署到github上，当然在其他步骤中它的作用也不可或缺。但是Git for Windows.   国内直接从<a href="http://git-scm.com/download/win">官网</a>下载比较困难，需要翻墙。<a href="https://github.com/Sjj1024/Git-win.git">这里</a>提供一个国内的下载站，方便网友下载。</p>
<h2 id="node-js和npm"><a href="#node-js和npm" class="headerlink" title="node.js和npm"></a>node.js和npm</h2><p>​       <a href="https://nodejs.org/en/download/">官网</a>下载适合你的node.js，推荐下载.msi文件，因为.msi文件可以自动帮你配置环境变量，省时方便，何乐而不为呢（<font color=#FF0000>但是这里要注意以管理员身份运行，不然会因没有权限更改环境变量而出现the error code is 2502，the error code is 2503</font>）点<a href="https://jingyan.baidu.com/article/6f2f55a15bf1d3b5b93e6c03.html">这里</a>学会如何以管理员身份运行.msi文件。最新版的node.js已经集成了npm，所以不需要额外安装npm。安装完成后可以运行Git Bush，在其中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>出现相应版本号即安装成功。</p>
<p>为了能有一个更好的下载体验，建议将将npm的注册表源设置为国内的镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获得原来的镜像地址</span><br><span class="line">npm get registry</span><br><span class="line">#设置为淘宝镜像</span><br><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line">#换成原来的</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br></pre></td></tr></table></figure>



<h1 id="二、创建GitHub博客仓库"><a href="#二、创建GitHub博客仓库" class="headerlink" title="二、创建GitHub博客仓库"></a>二、创建GitHub博客仓库</h1><p>1.创建仓库</p>
<p>2.配置SSH key</p>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>​      这一步登录你的github后，创建一个与你github重名的仓库，这里注意，此处只能创建与你github用户名一样的用户名，比如我的github用户名是SeanAristotle，那我的仓库名一定要是这个，等后续工作完成后，只需要打开:   <a href="https://seanaristotle.github.io/">https://seanaristotle.github.io</a> 就可以看到我的博客了。创建仓库需要一定的时间，大约需要半个小时，耐心等待即可。</p>
<h2 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h2><p>首先，先确定你是否有SSH Key，打开你的用户根目录，看看是否有.ssh这个文件夹，文件夹下是否有id_rsa和id_rsa.pub这两个文件。</p>
<img src="D:\Git\blog\source\images\ssh位置.png" style="zoom:50%;" />

<p>如果没有，就需要打开刚刚装好的Git Bush，输入下面的代码来创建(xxxx部分就是你的邮件地址)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxx@xxx.com&quot;</span><br></pre></td></tr></table></figure>

<p>然后，将SSH Key加到你的github中就可以了，</p>
<h1 id="三、安装并使用Hexo"><a href="#三、安装并使用Hexo" class="headerlink" title="三、安装并使用Hexo"></a>三、安装并使用Hexo</h1><p>1.安装Hexo</p>
<p>2.初始化</p>
<p>3.部署到GitHub</p>
<p>4.大功告成，写博客</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>这步so easy，打开你的Git Bush 输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>

<p>OK，这一步基本完成，如果出现： command not found: hexo可以参考<a href="https://www.jianshu.com/p/1851395f1f5f?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">这里</a></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在电脑中选择一部分空间作为你博客的存储空间，然后打开Git Bush，进入这个目录，（如，我的文件目录是D:/Git/blog）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入目录</span><br><span class="line">cd D:&#x2F;Git&#x2F;blog</span><br><span class="line"># 初始化</span><br><span class="line">hexo init</span><br><span class="line"># 生成</span><br><span class="line">hexo g</span><br><span class="line"># 启动</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>稍作等待，打开浏览器，访问<a href="http://localhost:4000就可以看到你的博客啦。如果4000这个端口被占用了，可以参考[这里](https://blog.csdn.net/Quincylk/article/details/8260309)来取舍到底哪个端口换一下。">http://localhost:4000就可以看到你的博客啦。如果4000这个端口被占用了，可以参考[这里](https://blog.csdn.net/Quincylk/article/details/8260309)来取舍到底哪个端口换一下。</a></p>
<h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><p>首先，到你的博客根目录中的_config.yml文件中，修改deploy部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git </span><br><span class="line">    repo: git@github.com:SeanAristotle&#x2F;SeanAristotle.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

<p>这里好像有点问题，但是不确定，等出现有人问问题再填坑吧！</p>
<p>然后打开Git Bush，安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>

<p>最后只要使用下面命令部署到github上就OK了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d </span><br></pre></td></tr></table></figure>

<h2 id="大功告成，写博客"><a href="#大功告成，写博客" class="headerlink" title="大功告成，写博客"></a>大功告成，写博客</h2><p>这下，你就可以开始写博客了，初始化时生成了个hello Hexo，里面有快捷指令的用法，然后就可以写博客了。</p>
<p>其实，只要记住三个命令就可以基本操作了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建新博客</span><br><span class="line">hexo new xxx</span><br><span class="line">#本地浏览</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo s -g    # 一句顶上面两句</span><br><span class="line">#上传部署到github</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo d -g     #同理</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>推荐一下我的Markdown编辑器<a href="https://typora.io/">Typora</a>,感觉超级好用。</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>​      关于主题，不建议不懂前端没有网页基础的人上来就搞，有这个时间多写两篇博客它不香吗？</p>
<p>​       希望自己有时间多写写，不管干什么，多学习，多总结总会有收获的。</p>
<h2 id="参考-amp-感谢"><a href="#参考-amp-感谢" class="headerlink" title="参考&amp;感谢"></a>参考&amp;感谢</h2><h3 id="包含但不限于文中链接和以下内容："><a href="#包含但不限于文中链接和以下内容：" class="headerlink" title="包含但不限于文中链接和以下内容："></a>包含但不限于文中链接和以下内容：</h3><p><a href="https://www.cnblogs.com/debugxw/p/11006734.html">https://www.cnblogs.com/debugxw/p/11006734.html</a></p>
<p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%B8%8A%E4%BC%A0%E5%88%B0github">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html#%E4%B8%8A%E4%BC%A0%E5%88%B0github</a></p>
<p><a href="https://garybear.cn/hexo-theme-meadow/doc/#/">https://garybear.cn/hexo-theme-meadow/doc/#/</a></p>
]]></content>
      <categories>
        <category>baldhead-experience</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>扬帆，起航！</title>
    <url>/7611/</url>
    <content><![CDATA[<h1 id="全新的开始"><a href="#全新的开始" class="headerlink" title="全新的开始"></a><center>全新的开始</center></h1><p>​       经过一系列的努力和忙碌，似乎一切都以尘埃落定。万万没想到，从计算机到电磁竟然还是没有逃出算法的手掌心。本来都想放弃算法和博客了，但是看到一个同是计算机到电磁的大佬写的博客，我也想为不管有意还是巧合而跨专业的探探路。（我去前面探探路！！！）虽然现在再写算法已经没有什么利益驱动了，就当是偶尔练练脑子，防止老年痴呆了。<strong>不忘初心，方得始终</strong> 想想2017年我们一起别无他想专心写代码的样子，心里真是羡慕的紧。现在回想一下，能够心无杂念的写写代码也是一种幸福。</p>
<a id="more"></a>

<p>​        废物了好久了，不想再把博客变成励志的技术东东，还是希望把自己的博客经营成一碗久违了的鸡汤，可以喝一喝，但是还是要认识现实的苦涩与忙碌。希望自己能在首都安安稳稳、稳扎稳打的生活下去，不要被这个城市遗忘。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>​        生活感悟只有鸡汤，如何搭建的明天秃头经历里慢慢写。</p>
<p>​       期望自己能够在忙碌中找点时间继续安心的写写代码，做做博客。最后安利一下我自己的博客<a href="https://seanaristotle.github.io/">欢迎来访</a>。</p>
]]></content>
      <categories>
        <category>program-life</category>
      </categories>
      <tags>
        <tag>生活感悟</tag>
      </tags>
  </entry>
</search>
